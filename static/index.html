<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Google Play â€“ Top 100 Apps</title>
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>
  <style>
    /* â”€â”€ Reset & Base â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
    *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }
    body {
      font-family: 'Segoe UI', Roboto, Arial, sans-serif;
      background: #0f1117;
      color: #e0e0e0;
      min-height: 100vh;
    }

    /* â”€â”€ Header â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
    header {
      background: linear-gradient(135deg, #1a1c2e 0%, #2d1f4e 100%);
      padding: 28px 32px 18px;
      text-align: center;
      border-bottom: 2px solid #7c3aed;
    }
    header h1 {
      font-size: 1.8rem;
      color: #a78bfa;
      letter-spacing: .5px;
    }
    header p {
      margin-top: 6px;
      font-size: .9rem;
      color: #9ca3af;
    }

    /* â”€â”€ Tab Bar â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
    .tabs {
      display: flex;
      justify-content: center;
      gap: 10px;
      flex-wrap: wrap;
      padding: 16px 24px;
      background: #13151f;
    }
    .tab-btn {
      padding: 8px 20px;
      border: 1px solid #374151;
      border-radius: 999px;
      background: transparent;
      color: #9ca3af;
      font-size: .85rem;
      cursor: pointer;
      transition: all .2s;
    }
    .tab-btn:hover { border-color: #7c3aed; color: #c4b5fd; }
    .tab-btn.active {
      background: #7c3aed;
      color: #fff;
      border-color: #7c3aed;
    }

    /* â”€â”€ Main â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
    main { max-width: 1100px; margin: 0 auto; padding: 24px; }

    .section-title {
      font-size: 1.3rem;
      color: #c4b5fd;
      margin-bottom: 16px;
    }

    /* â”€â”€ Loading / Error â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
    .loading, .error {
      text-align: center;
      padding: 60px 20px;
      font-size: 1.1rem;
    }
    .loading { color: #7c3aed; }
    .error   { color: #ef4444; }
    .spinner {
      width: 40px; height: 40px;
      border: 4px solid #1e1e2e;
      border-top-color: #7c3aed;
      border-radius: 50%;
      animation: spin .8s linear infinite;
      margin: 0 auto 16px;
    }
    @keyframes spin { to { transform: rotate(360deg); } }

    /* â”€â”€ Card Grid â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
    .grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(320px, 1fr));
      gap: 14px;
    }

    .card {
      display: flex;
      align-items: center;
      gap: 14px;
      background: #1a1c2e;
      border: 1px solid #272a3a;
      border-radius: 12px;
      padding: 14px 16px;
      transition: border-color .2s, transform .15s;
    }
    .card:hover {
      border-color: #7c3aed;
      transform: translateY(-2px);
    }

    .rank {
      font-size: 1.1rem;
      font-weight: 700;
      color: #7c3aed;
      min-width: 30px;
      text-align: center;
    }
    .rank.top3 { color: #facc15; font-size: 1.3rem; }

    .icon {
      width: 52px; height: 52px;
      border-radius: 12px;
      object-fit: cover;
      flex-shrink: 0;
      background: #272a3a;
    }

    .info { flex: 1; min-width: 0; }
    .info .name {
      font-size: .95rem;
      font-weight: 600;
      color: #e5e7eb;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    .info .dev {
      font-size: .78rem;
      color: #9ca3af;
      margin-top: 2px;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .meta {
      text-align: right;
      flex-shrink: 0;
    }
    .meta .installs {
      font-size: .8rem;
      color: #a78bfa;
      font-weight: 600;
    }
    .meta .rating {
      font-size: .78rem;
      color: #facc15;
      margin-top: 4px;
    }
    .meta .genre {
      font-size: .7rem;
      color: #6b7280;
      margin-top: 2px;
    }

    a.card-link { text-decoration: none; color: inherit; }

    /* â”€â”€ Keyword Pills â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
    .keywords-section {
      margin-bottom: 32px;
    }
    .keywords-grid {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
    }
    .kw-pill {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      background: #1a1c2e;
      border: 1px solid #272a3a;
      border-radius: 999px;
      padding: 8px 18px;
      font-size: .85rem;
      color: #c4b5fd;
      transition: border-color .2s, transform .15s;
    }
    .kw-pill:hover {
      border-color: #7c3aed;
      transform: translateY(-2px);
    }
    .kw-rank {
      font-weight: 700;
      color: #7c3aed;
      font-size: .8rem;
    }
    .kw-name {
      font-weight: 500;
    }
    .kw-count {
      font-size: .72rem;
      color: #6b7280;
    }

    /* â”€â”€ Footer â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
    footer {
      text-align: center;
      padding: 24px;
      font-size: .75rem;
      color: #4b5563;
    }

    /* â”€â”€ Responsive â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
    @media (max-width: 600px) {
      .grid { grid-template-columns: 1fr; }
      header h1 { font-size: 1.3rem; }
      .modal-body { padding: 20px; max-width: 100%; }
      .detail-screenshots { gap: 8px; }
      .detail-screenshots img { height: 160px; }
    }

    /* â”€â”€ Detail Modal â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
    .modal-overlay {
      display: none;
      position: fixed;
      inset: 0;
      z-index: 1000;
      background: rgba(0, 0, 0, .75);
      backdrop-filter: blur(4px);
      justify-content: center;
      align-items: flex-start;
      padding: 40px 16px;
      overflow-y: auto;
    }
    .modal-overlay.open { display: flex; }

    .modal-body {
      background: #1a1c2e;
      border: 1px solid #374151;
      border-radius: 16px;
      max-width: 720px;
      width: 100%;
      padding: 28px 32px;
      position: relative;
      animation: slideUp .25s ease;
    }
    @keyframes slideUp {
      from { opacity: 0; transform: translateY(30px); }
      to   { opacity: 1; transform: translateY(0); }
    }

    .modal-close {
      position: absolute;
      top: 14px; right: 18px;
      background: none; border: none;
      color: #9ca3af;
      font-size: 1.5rem;
      cursor: pointer;
      transition: color .2s;
    }
    .modal-close:hover { color: #fff; }

    .detail-header {
      display: flex;
      gap: 18px;
      align-items: center;
      margin-bottom: 20px;
    }
    .detail-header img {
      width: 72px; height: 72px;
      border-radius: 16px;
      object-fit: cover;
      background: #272a3a;
    }
    .detail-header .detail-title {
      font-size: 1.3rem;
      font-weight: 700;
      color: #e5e7eb;
    }
    .detail-header .detail-dev {
      font-size: .85rem;
      color: #9ca3af;
      margin-top: 2px;
    }
    .detail-header .detail-genre-badge {
      display: inline-block;
      margin-top: 6px;
      padding: 3px 10px;
      border-radius: 999px;
      background: #272a3a;
      font-size: .72rem;
      color: #a78bfa;
    }

    .detail-stats {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(130px, 1fr));
      gap: 12px;
      margin-bottom: 22px;
    }
    .stat-card {
      background: #13151f;
      border-radius: 10px;
      padding: 14px;
      text-align: center;
    }
    .stat-card .stat-value {
      font-size: 1.1rem;
      font-weight: 700;
      color: #c4b5fd;
    }
    .stat-card .stat-label {
      font-size: .72rem;
      color: #6b7280;
      margin-top: 4px;
    }

    .detail-description {
      background: #13151f;
      border-radius: 10px;
      padding: 16px;
      margin-bottom: 18px;
      max-height: 260px;
      overflow-y: auto;
      font-size: .85rem;
      line-height: 1.6;
      color: #d1d5db;
      white-space: pre-line;
    }

    .detail-screenshots {
      display: flex;
      gap: 10px;
      overflow-x: auto;
      padding-bottom: 8px;
      margin-bottom: 18px;
    }
    .detail-screenshots img {
      height: 200px;
      border-radius: 10px;
      object-fit: cover;
      flex-shrink: 0;
    }

    .detail-footer {
      display: flex;
      justify-content: space-between;
      align-items: center;
      flex-wrap: wrap;
      gap: 10px;
    }
    .detail-footer a {
      display: inline-block;
      padding: 10px 24px;
      background: #7c3aed;
      color: #fff;
      border-radius: 999px;
      text-decoration: none;
      font-size: .85rem;
      font-weight: 600;
      transition: background .2s;
    }
    .detail-footer a:hover { background: #6d28d9; }
    .detail-footer .detail-meta-info {
      font-size: .72rem;
      color: #6b7280;
    }

    /* â”€â”€ Niche Finder â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
    .niche-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
      gap: 14px;
      margin-bottom: 24px;
    }
    .niche-card {
      background: #1a1c2e;
      border: 1px solid #272a3a;
      border-radius: 12px;
      padding: 18px;
      transition: border-color .2s, transform .15s;
      cursor: pointer;
    }
    .niche-card:hover {
      border-color: #7c3aed;
      transform: translateY(-2px);
    }
    .niche-card .niche-name {
      font-size: 1.05rem;
      font-weight: 700;
      color: #e5e7eb;
      margin-bottom: 10px;
    }
    .niche-card .score-bar {
      height: 8px;
      border-radius: 4px;
      background: #272a3a;
      margin-bottom: 10px;
      overflow: hidden;
    }
    .niche-card .score-bar-fill {
      height: 100%;
      border-radius: 4px;
      transition: width .5s;
    }
    .niche-metrics {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 6px;
    }
    .niche-metric {
      font-size: .75rem;
      color: #9ca3af;
    }
    .niche-metric strong {
      color: #c4b5fd;
    }
    .opportunity-badge {
      display: inline-block;
      padding: 3px 10px;
      border-radius: 999px;
      font-size: .78rem;
      font-weight: 700;
      margin-bottom: 8px;
    }
    .opp-high   { background: #065f46; color: #34d399; }
    .opp-medium { background: #713f12; color: #fbbf24; }
    .opp-low    { background: #7f1d1d; color: #f87171; }

    /* â”€â”€ Toolbar â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
    .toolbar {
      display: flex;
      justify-content: flex-end;
      gap: 10px;
      flex-wrap: wrap;
      margin-bottom: 16px;
    }
    .toolbar-btn {
      padding: 6px 16px;
      border: 1px solid #374151;
      border-radius: 8px;
      background: #1a1c2e;
      color: #9ca3af;
      font-size: .78rem;
      cursor: pointer;
      transition: all .2s;
    }
    .toolbar-btn:hover {
      border-color: #7c3aed;
      color: #c4b5fd;
    }

    /* â”€â”€ Snapshot diff â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
    .diff-section { margin-bottom: 20px; }
    .diff-section h3 {
      font-size: 1rem;
      color: #c4b5fd;
      margin-bottom: 8px;
    }
    .diff-item {
      background: #1a1c2e;
      border: 1px solid #272a3a;
      border-radius: 8px;
      padding: 10px 14px;
      margin-bottom: 6px;
      font-size: .82rem;
    }
    .diff-item .change-positive { color: #34d399; font-weight: 600; }
    .diff-item .change-negative { color: #f87171; font-weight: 600; }

    /* â”€â”€ IP Blocked Modal â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
    .blocked-overlay {
      position: fixed;
      inset: 0;
      z-index: 10000;
      background: rgba(0,0,0,.75);
      display: flex;
      justify-content: center;
      align-items: center;
      opacity: 0;
      pointer-events: none;
      transition: opacity .25s;
    }
    .blocked-overlay.open {
      opacity: 1;
      pointer-events: auto;
    }
    .blocked-box {
      background: #1c1e30;
      border: 2px solid #f87171;
      border-radius: 16px;
      padding: 32px 28px;
      max-width: 440px;
      width: 90%;
      text-align: center;
    }
    .blocked-box .blocked-icon { font-size: 3rem; margin-bottom: 12px; }
    .blocked-box h2 {
      color: #f87171;
      font-size: 1.3rem;
      margin-bottom: 10px;
    }
    .blocked-box p {
      color: #d1d5db;
      font-size: .88rem;
      line-height: 1.5;
      margin-bottom: 18px;
    }
    .blocked-box .countdown {
      font-size: .82rem;
      color: #9ca3af;
      margin-bottom: 14px;
    }
    .blocked-box button {
      padding: 8px 22px;
      border-radius: 8px;
      border: none;
      background: #374151;
      color: #e0e0e0;
      cursor: pointer;
      font-size: .85rem;
      font-weight: 600;
      transition: background .2s;
    }
    .blocked-box button:hover { background: #4b5563; }

    /* â”€â”€ Throttle / Cooldown Toast â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
    .throttle-overlay {
      position: fixed;
      top: 20px;
      right: 20px;
      z-index: 9999;
      opacity: 0;
      pointer-events: none;
      transform: translateX(120%);
      transition: transform .35s ease, opacity .25s ease;
    }
    .throttle-overlay.open {
      opacity: 1;
      pointer-events: auto;
      transform: translateX(0);
    }
    .throttle-box {
      background: #1c1e30;
      border: 2px solid #f59e0b;
      border-radius: 14px;
      padding: 20px 24px;
      min-width: 280px;
      max-width: 360px;
      box-shadow: 0 8px 32px rgba(0,0,0,.5);
    }
    .throttle-box .throttle-header {
      display: flex;
      align-items: center;
      gap: 10px;
      margin-bottom: 10px;
    }
    .throttle-box .throttle-icon { font-size: 1.6rem; }
    .throttle-box .throttle-title {
      font-size: 1rem;
      font-weight: 700;
      color: #f59e0b;
    }
    .throttle-box p {
      color: #d1d5db;
      font-size: .82rem;
      line-height: 1.45;
      margin-bottom: 12px;
    }
    .throttle-timer {
      display: flex;
      align-items: center;
      gap: 10px;
      margin-bottom: 8px;
    }
    .throttle-timer .timer-ring {
      width: 44px;
      height: 44px;
      flex-shrink: 0;
    }
    .throttle-timer .timer-ring circle {
      fill: none;
      stroke-width: 4;
    }
    .throttle-timer .timer-ring .ring-bg {
      stroke: #374151;
    }
    .throttle-timer .timer-ring .ring-fg {
      stroke: #f59e0b;
      stroke-linecap: round;
      transition: stroke-dashoffset .95s linear;
    }
    .throttle-timer .timer-text {
      font-size: 1.3rem;
      font-weight: 700;
      color: #fbbf24;
      font-variant-numeric: tabular-nums;
    }
    .throttle-timer .timer-label {
      font-size: .75rem;
      color: #9ca3af;
    }
    .throttle-bar {
      height: 4px;
      background: #374151;
      border-radius: 4px;
      overflow: hidden;
      margin-bottom: 6px;
    }
    .throttle-bar .throttle-fill {
      height: 100%;
      background: #f59e0b;
      border-radius: 4px;
      transition: width .95s linear;
    }
    .throttle-box .dismiss-link {
      display: block;
      text-align: right;
      font-size: .75rem;
      color: #6b7280;
      cursor: pointer;
      text-decoration: underline;
    }
    .throttle-box .dismiss-link:hover { color: #9ca3af; }

    /* â”€â”€ ETA timer â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
    .eta-wrap {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 8px;
      margin-top: 10px;
    }
    .eta-bar-outer {
      width: 220px;
      height: 6px;
      background: #1e1e2e;
      border-radius: 6px;
      overflow: hidden;
    }
    .eta-bar-inner {
      height: 100%;
      width: 0%;
      background: linear-gradient(90deg, #7c3aed, #a78bfa);
      border-radius: 6px;
      transition: width 1s linear;
    }
    .eta-text {
      font-size: .85rem;
      color: #9ca3af;
      font-variant-numeric: tabular-nums;
    }
    .eta-text span {
      color: #c4b5fd;
      font-weight: 600;
    }

    /* â”€â”€ Welcome / Landing Page â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
    .welcome {
      text-align: center;
      padding: 40px 20px 20px;
    }
    .welcome h2 {
      font-size: 1.6rem;
      color: #c4b5fd;
      margin-bottom: 8px;
    }
    .welcome .subtitle {
      color: #9ca3af;
      font-size: .92rem;
      margin-bottom: 28px;
      line-height: 1.5;
    }
    .welcome-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(230px, 1fr));
      gap: 14px;
      text-align: left;
    }
    .welcome-card {
      background: #1a1c2e;
      border: 1px solid #272a3a;
      border-radius: 12px;
      padding: 18px 20px;
      cursor: pointer;
      transition: all .2s;
      display: flex;
      flex-direction: column;
      gap: 8px;
    }
    .welcome-card:hover {
      border-color: #7c3aed;
      transform: translateY(-2px);
      box-shadow: 0 4px 20px rgba(124,58,237,.15);
    }
    .welcome-card .wc-name {
      font-size: 1rem;
      font-weight: 600;
      color: #e0e0e0;
      display: flex;
      align-items: center;
      gap: 8px;
    }
    .welcome-card .wc-name .wc-icon {
      font-size: 1.25rem;
    }
    .welcome-card .wc-cache {
      font-size: .72rem;
      display: flex;
      align-items: center;
      gap: 6px;
    }
    .welcome-card .wc-dot {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      flex-shrink: 0;
    }
    .wc-dot.fresh   { background: #34d399; }
    .wc-dot.stale   { background: #f59e0b; }
    .wc-dot.none    { background: #4b5563; }
    .wc-cache-text  { color: #6b7280; }
    .wc-cache-text.fresh { color: #34d399; }
    .wc-cache-text.stale { color: #f59e0b; }
    .wc-fresh-msg {
      background: #0d2818;
      border: 1px solid #166534;
      border-radius: 8px;
      padding: 10px 16px;
      margin-bottom: 18px;
      font-size: .82rem;
      color: #34d399;
      line-height: 1.4;
    }
    .wc-fresh-msg strong { color: #6ee7b7; }

    /* â”€â”€ Analysis / Compare â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
    .analysis-panel {
      margin-bottom: 24px;
    }
    .compare-form {
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
      align-items: flex-end;
      margin-bottom: 20px;
    }
    .compare-form label {
      font-size: .78rem;
      color: #9ca3af;
      display: flex;
      flex-direction: column;
      gap: 4px;
    }
    .compare-form input, .compare-form select {
      padding: 8px 12px;
      border: 1px solid #374151;
      border-radius: 8px;
      background: #1a1c2e;
      color: #e0e0e0;
      font-size: .85rem;
      min-width: 220px;
    }
    .compare-form input:focus, .compare-form select:focus {
      border-color: #7c3aed;
      outline: none;
    }
    .compare-btn {
      padding: 8px 20px;
      background: #7c3aed;
      color: #fff;
      border: none;
      border-radius: 8px;
      cursor: pointer;
      font-size: .85rem;
      font-weight: 600;
      transition: background .2s;
    }
    .compare-btn:hover { background: #6d28d9; }

    .compare-result {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 16px;
      margin-bottom: 24px;
    }
    @media (max-width: 700px) {
      .compare-result { grid-template-columns: 1fr; }
    }
    .compare-app-card {
      background: #1a1c2e;
      border: 1px solid #272a3a;
      border-radius: 12px;
      padding: 18px;
    }
    .compare-app-card .app-hdr {
      display: flex;
      gap: 12px;
      align-items: center;
      margin-bottom: 12px;
    }
    .compare-app-card .app-hdr img {
      width: 48px; height: 48px;
      border-radius: 12px;
    }
    .compare-app-card .app-hdr .app-title {
      font-weight: 700;
      color: #e5e7eb;
    }
    .compare-app-card .app-hdr .app-dev {
      font-size: .78rem;
      color: #9ca3af;
    }

    .word-section {
      background: #1a1c2e;
      border: 1px solid #272a3a;
      border-radius: 12px;
      padding: 16px;
      margin-bottom: 16px;
    }
    .word-section h3 {
      font-size: .95rem;
      color: #c4b5fd;
      margin-bottom: 10px;
    }
    .word-chips {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
    }
    .word-chip {
      display: inline-block;
      padding: 4px 10px;
      border-radius: 999px;
      font-size: .75rem;
      font-weight: 500;
    }
    .word-chip.shared  { background: #1e3a5f; color: #60a5fa; }
    .word-chip.only1   { background: #3b1f5e; color: #c084fc; }
    .word-chip.only2   { background: #1e3b3b; color: #34d399; }

    .chart-container {
      background: #1a1c2e;
      border: 1px solid #272a3a;
      border-radius: 12px;
      padding: 18px;
      margin-bottom: 20px;
    }
    .chart-container canvas {
      max-height: 320px;
    }
    .overlap-badge {
      display: inline-block;
      padding: 4px 14px;
      border-radius: 999px;
      font-size: .82rem;
      font-weight: 700;
      background: #272a3a;
      color: #a78bfa;
      margin-bottom: 14px;
    }

    /* â”€â”€ Request Log Sidebar â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
    .sidebar-toggle {
      position: fixed;
      bottom: 24px;
      right: 24px;
      z-index: 10001;
      width: 48px;
      height: 48px;
      border-radius: 50%;
      border: 2px solid #374151;
      background: #1a1c2e;
      color: #a78bfa;
      font-size: 1.3rem;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all .25s;
      box-shadow: 0 4px 16px rgba(0,0,0,.4);
    }
    .sidebar-toggle:hover {
      border-color: #7c3aed;
      background: #272a3a;
      transform: scale(1.08);
    }
    .sidebar-toggle .badge {
      position: absolute;
      top: -4px;
      right: -4px;
      background: #7c3aed;
      color: #fff;
      font-size: .65rem;
      font-weight: 700;
      width: 20px;
      height: 20px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      pointer-events: none;
    }
    .sidebar-toggle .badge.has-error {
      background: #ef4444;
    }
    .req-sidebar {
      position: fixed;
      top: 0;
      right: 0;
      width: 370px;
      height: 100vh;
      z-index: 10000;
      background: #13151f;
      border-left: 2px solid #272a3a;
      transform: translateX(100%);
      transition: transform .3s ease;
      display: flex;
      flex-direction: column;
      box-shadow: -4px 0 24px rgba(0,0,0,.4);
    }
    .req-sidebar.open {
      transform: translateX(0);
    }
    .req-sidebar-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 16px 18px;
      border-bottom: 1px solid #272a3a;
      flex-shrink: 0;
    }
    .req-sidebar-header h3 {
      font-size: 1rem;
      color: #c4b5fd;
      display: flex;
      align-items: center;
      gap: 8px;
    }
    .req-sidebar-header .clear-btn {
      background: none;
      border: 1px solid #374151;
      color: #9ca3af;
      font-size: .72rem;
      padding: 4px 10px;
      border-radius: 6px;
      cursor: pointer;
      transition: all .2s;
    }
    .req-sidebar-header .clear-btn:hover {
      border-color: #ef4444;
      color: #f87171;
    }
    .req-sidebar-header .close-sb {
      background: none;
      border: none;
      color: #6b7280;
      font-size: 1.3rem;
      cursor: pointer;
      margin-left: 8px;
    }
    .req-sidebar-header .close-sb:hover { color: #e0e0e0; }
    .req-sidebar-list {
      flex: 1;
      overflow-y: auto;
      padding: 8px 0;
    }
    .req-sidebar-list::-webkit-scrollbar { width: 5px; }
    .req-sidebar-list::-webkit-scrollbar-thumb { background: #374151; border-radius: 4px; }
    .req-sidebar-empty {
      text-align: center;
      color: #4b5563;
      padding: 50px 20px;
      font-size: .85rem;
    }
    .req-entry {
      display: flex;
      align-items: flex-start;
      gap: 10px;
      padding: 10px 18px;
      border-bottom: 1px solid #1e1e2e;
      transition: background .15s;
      cursor: default;
    }
    .req-entry:hover {
      background: #1a1c2e;
    }
    .req-entry .req-dot {
      width: 10px;
      height: 10px;
      border-radius: 50%;
      margin-top: 5px;
      flex-shrink: 0;
    }
    .req-entry .req-dot.ok      { background: #34d399; }
    .req-entry .req-dot.fail    { background: #ef4444; }
    .req-entry .req-dot.pending { background: #f59e0b; animation: pulse-dot 1s ease infinite; }
    @keyframes pulse-dot {
      0%, 100% { opacity: 1; }
      50%      { opacity: .35; }
    }
    .req-entry .req-body {
      flex: 1;
      min-width: 0;
    }
    .req-entry .req-url {
      font-size: .78rem;
      color: #d1d5db;
      font-family: 'Courier New', monospace;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    .req-entry .req-meta {
      display: flex;
      align-items: center;
      gap: 8px;
      margin-top: 3px;
      font-size: .7rem;
      color: #6b7280;
    }
    .req-entry .req-meta .status-ok   { color: #34d399; font-weight: 600; }
    .req-entry .req-meta .status-fail { color: #ef4444; font-weight: 600; }
    .req-entry .req-reason {
      margin-top: 4px;
      font-size: .7rem;
      color: #f87171;
      line-height: 1.3;
      word-break: break-word;
    }
    .req-entry .req-time {
      font-size: .65rem;
      color: #4b5563;
      white-space: nowrap;
      margin-top: 5px;
      flex-shrink: 0;
    }
  </style>
</head>
<body>

<header>
  <h1>ğŸ“± Google Play â€“ Top 100 Apps</h1>
  <p>Most downloaded &amp; popular apps this week</p>
</header>

<nav class="tabs" id="tabs">
  <button class="tab-btn active" data-endpoint="welcome">ğŸ  Home</button>
  <button class="tab-btn" data-endpoint="/api/top">All</button>
  <button class="tab-btn" data-endpoint="anime">ğŸŒ Anime</button>
  <button class="tab-btn" data-endpoint="niche-finder">ğŸ” Niche Finder</button>
  <button class="tab-btn" data-endpoint="analysis">ğŸ“Š Analysis</button>
  <!-- category buttons injected dynamically -->
</nav>

<!-- IP blocked modal -->
<div id="blockedOverlay" class="blocked-overlay">
  <div class="blocked-box">
    <div class="blocked-icon">ğŸš«</div>
    <h2>IP Temporarily Blocked</h2>
    <p id="blockedMsg">Google Play has rate-limited requests from this IP. Cached data is still available, but new scrapes will fail until the block expires.</p>
    <div class="countdown" id="blockedCountdown"></div>
    <button onclick="closeBlockedModal()">Dismiss</button>
  </div>
</div>

<!-- Throttle cooldown toast -->
<div id="throttleOverlay" class="throttle-overlay">
  <div class="throttle-box">
    <div class="throttle-header">
      <span class="throttle-icon">â³</span>
      <span class="throttle-title" id="throttleTitle">Cooldown Active</span>
    </div>
    <p id="throttleMsg">Waiting between requests to avoid getting blocked by Google Play.</p>
    <div class="throttle-timer">
      <svg class="timer-ring" viewBox="0 0 44 44">
        <circle class="ring-bg" cx="22" cy="22" r="18" />
        <circle class="ring-fg" id="throttleRing" cx="22" cy="22" r="18"
                stroke-dasharray="113.1" stroke-dashoffset="0" />
      </svg>
      <div>
        <div class="timer-text" id="throttleCountdown">10s</div>
        <div class="timer-label">remaining</div>
      </div>
    </div>
    <div class="throttle-bar"><div class="throttle-fill" id="throttleFill" style="width:100%"></div></div>
    <span class="dismiss-link" onclick="closeThrottleModal()">dismiss</span>
  </div>
</div>

<!-- Request Log Sidebar -->
<button class="sidebar-toggle" id="sidebarToggle" title="Request Log">
  ğŸ“‹<span class="badge" id="sidebarBadge" style="display:none">0</span>
</button>
<aside class="req-sidebar" id="reqSidebar">
  <div class="req-sidebar-header">
    <h3>ğŸ“‹ Request Log</h3>
    <div>
      <button class="clear-btn" id="clearLogBtn">Clear</button>
      <button class="close-sb" id="closeSidebar">&times;</button>
    </div>
  </div>
  <div class="req-sidebar-list" id="reqList">
    <div class="req-sidebar-empty">No requests yet</div>
  </div>
</aside>

<main id="content">
  <!-- cards rendered here -->
</main>

<footer>
  Data sourced from Google Play via google-play-scraper &middot; refreshed on each request
</footer>

<!-- App Detail Modal -->
<div class="modal-overlay" id="modal">
  <div class="modal-body" id="modalBody">
    <button class="modal-close" id="modalClose">&times;</button>
    <div id="modalContent"></div>
  </div>
</div>

<script>
  const $content = document.getElementById("content");
  const $tabs    = document.getElementById("tabs");
  const $blockedOverlay = document.getElementById("blockedOverlay");
  const $blockedMsg     = document.getElementById("blockedMsg");
  const $blockedCount   = document.getElementById("blockedCountdown");
  let _blockedTimer     = null;

  // â”€â”€ IP-blocked modal helpers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  function showBlockedModal(message) {
    $blockedMsg.textContent = message || $blockedMsg.textContent;
    $blockedOverlay.classList.add("open");

    let secs = 120;
    clearInterval(_blockedTimer);
    tick();
    _blockedTimer = setInterval(tick, 1000);
    function tick() {
      const m = Math.floor(secs / 60);
      const s = String(secs % 60).padStart(2, "0");
      $blockedCount.textContent = `Suggested wait: ${m}:${s}`;
      if (secs <= 0) {
        clearInterval(_blockedTimer);
        $blockedCount.textContent = "You can try again now.";
      }
      secs--;
    }
  }
  function closeBlockedModal() {
    $blockedOverlay.classList.remove("open");
    clearInterval(_blockedTimer);
  }

  // â”€â”€ Request Log sidebar â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const $reqSidebar  = document.getElementById("reqSidebar");
  const $reqList     = document.getElementById("reqList");
  const $sidebarBadge = document.getElementById("sidebarBadge");
  const _requestLog  = [];    // {id, url, status, statusText, duration, error, time}
  let _reqIdCounter  = 0;

  document.getElementById("sidebarToggle").addEventListener("click", () => {
    $reqSidebar.classList.toggle("open");
  });
  document.getElementById("closeSidebar").addEventListener("click", () => {
    $reqSidebar.classList.remove("open");
  });
  document.getElementById("clearLogBtn").addEventListener("click", () => {
    _requestLog.length = 0;
    _renderReqLog();
  });

  function _addReqEntry(entry) {
    _requestLog.unshift(entry);  // newest first
    if (_requestLog.length > 200) _requestLog.pop();
    _renderReqLog();
  }

  function _updateReqEntry(id, updates) {
    const e = _requestLog.find(r => r.id === id);
    if (e) Object.assign(e, updates);
    _renderReqLog();
  }

  function _renderReqLog() {
    const errorCount = _requestLog.filter(r => r.status === 'error').length;
    const total = _requestLog.length;

    // Badge
    if (total > 0) {
      $sidebarBadge.style.display = '';
      $sidebarBadge.textContent = total > 99 ? '99+' : total;
      $sidebarBadge.classList.toggle('has-error', errorCount > 0);
    } else {
      $sidebarBadge.style.display = 'none';
    }

    if (total === 0) {
      $reqList.innerHTML = '<div class="req-sidebar-empty">No requests yet</div>';
      return;
    }

    let html = '';
    for (const r of _requestLog) {
      const dotClass = r.status === 'pending' ? 'pending'
                     : r.status === 'error'   ? 'fail'
                     : 'ok';
      const statusLabel = r.status === 'pending'
        ? '<span style="color:#f59e0b">pendingâ€¦</span>'
        : r.status === 'error'
          ? `<span class="status-fail">${_escLog(r.statusCode || 'ERR')}</span>`
          : `<span class="status-ok">${r.statusCode || '200'}</span>`;
      const durLabel = r.duration != null ? (r.duration < 1000 ? r.duration + 'ms' : (r.duration / 1000).toFixed(1) + 's') : '';
      const shortUrl = r.url.replace(/^\/api\//, '');
      html += `
        <div class="req-entry">
          <div class="req-dot ${dotClass}"></div>
          <div class="req-body">
            <div class="req-url" title="${_escLog(r.url)}">${_escLog(shortUrl)}</div>
            <div class="req-meta">
              ${statusLabel}
              ${durLabel ? '<span>Â· ' + durLabel + '</span>' : ''}
            </div>
            ${r.error ? '<div class="req-reason">âš  ' + _escLog(r.error) + '</div>' : ''}
          </div>
          <div class="req-time">${r.timeStr}</div>
        </div>`;
    }
    $reqList.innerHTML = html;
  }

  function _escLog(s) {
    const d = document.createElement('div');
    d.textContent = String(s || '');
    return d.innerHTML;
  }

  function _nowTimeStr() {
    const d = new Date();
    return d.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit', second: '2-digit' });
  }

  /** Wrapper around fetch that auto-detects 429 blocked responses
   *  and logs every request to the sidebar. */
  async function apiFetch(url, opts) {
    const reqId = ++_reqIdCounter;
    const t0 = performance.now();
    _addReqEntry({
      id: reqId,
      url: url,
      status: 'pending',
      statusCode: null,
      duration: null,
      error: null,
      timeStr: _nowTimeStr(),
    });

    try {
      const res = await fetch(url, opts);
      const dur = Math.round(performance.now() - t0);

      if (res.status === 429) {
        let msg = '';
        try { const body = await res.clone().json(); msg = body.error || ''; } catch (_) {}
        _updateReqEntry(reqId, { status: 'error', statusCode: '429', duration: dur, error: msg || 'IP blocked (429)' });
        showBlockedModal(msg);
        throw new Error(msg || 'IP blocked (429)');
      }

      if (!res.ok) {
        _updateReqEntry(reqId, { status: 'error', statusCode: String(res.status), duration: dur, error: res.statusText });
      } else {
        _updateReqEntry(reqId, { status: 'ok', statusCode: String(res.status), duration: dur });
      }
      return res;
    } catch (err) {
      const dur = Math.round(performance.now() - t0);
      if (err.name === 'AbortError') {
        _updateReqEntry(reqId, { status: 'error', statusCode: 'ABORT', duration: dur, error: 'Request cancelled (tab switch)' });
      } else {
        // Only update if not already set (e.g. by 429 handler above)
        const existing = _requestLog.find(r => r.id === reqId);
        if (existing && existing.status === 'pending') {
          _updateReqEntry(reqId, { status: 'error', statusCode: 'ERR', duration: dur, error: err.message });
        }
      }
      throw err;
    }
  }

  // â”€â”€ Throttle / Cooldown toast â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const $throttleOverlay = document.getElementById("throttleOverlay");
  const $throttleTitle   = document.getElementById("throttleTitle");
  const $throttleMsg     = document.getElementById("throttleMsg");
  const $throttleCount   = document.getElementById("throttleCountdown");
  const $throttleRing    = document.getElementById("throttleRing");
  const $throttleFill    = document.getElementById("throttleFill");
  let _throttleTimer     = null;
  let _lastTabClick      = 0;        // timestamp of last tab switch
  const TAB_COOLDOWN     = 10;       // seconds between tab switches
  const RING_CIRCUM      = 113.1;    // 2Ï€r for r=18

  function showThrottleModal(totalSecs, title, msg) {
    $throttleTitle.textContent = title || "Cooldown Active";
    $throttleMsg.textContent   = msg   || "Waiting between requests to avoid getting blocked by Google Play.";
    $throttleOverlay.classList.add("open");

    let remaining = totalSecs;
    clearInterval(_throttleTimer);
    updateRing(remaining, totalSecs);
    _throttleTimer = setInterval(() => {
      remaining--;
      updateRing(remaining, totalSecs);
      if (remaining <= 0) {
        clearInterval(_throttleTimer);
        setTimeout(() => $throttleOverlay.classList.remove("open"), 600);
      }
    }, 1000);
  }

  function updateRing(remaining, total) {
    const pct = Math.max(0, remaining / total);
    $throttleCount.textContent = remaining + "s";
    $throttleRing.style.strokeDashoffset = RING_CIRCUM * (1 - pct);
    $throttleFill.style.width = (pct * 100) + "%";
  }

  function closeThrottleModal() {
    $throttleOverlay.classList.remove("open");
    clearInterval(_throttleTimer);
  }

  /**
   * Check if user is switching tabs too fast.
   * Returns true if the request should proceed, false if throttled.
   */
  function checkTabCooldown() {
    const now = Date.now() / 1000;
    const elapsed = now - _lastTabClick;
    if (_lastTabClick > 0 && elapsed < TAB_COOLDOWN) {
      const wait = Math.ceil(TAB_COOLDOWN - elapsed);
      showThrottleModal(wait,
        "Slow Down â€” Cooldown",
        "Switching tabs too fast can trigger rate limits. Please wait."
      );
      return false;
    }
    _lastTabClick = now;
    return true;
  }

  /**
   * Poll the backend throttle status and show/update the toast
   * while a scrape request is in flight.
   */
  async function pollThrottleWhileLoading(signal) {
    try {
      const res = await fetch("/api/throttle-status", { signal });
      if (!res.ok) return;
      const data = await res.json();
      if (data.waiting && data.waitSeconds > 0) {
        showThrottleModal(
          Math.ceil(data.waitSeconds),
          "Database Delay Active",
          "The scraper is waiting to respect rate limits. Data will load automatically."
        );
      }
    } catch (_) { /* ignore */ }
  }

  // â”€â”€ Render helpers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  let _etaTimer = null;

  function _startEtaCountdown(totalSecs) {
    clearInterval(_etaTimer);
    let elapsed = 0;
    const $bar   = document.getElementById("etaBar");
    const $count = document.getElementById("etaCount");
    if (!$bar || !$count) return;
    _etaTimer = setInterval(() => {
      elapsed++;
      const pct = Math.min(100, (elapsed / totalSecs) * 100);
      $bar.style.width = pct + "%";
      const remaining = Math.max(0, Math.ceil(totalSecs - elapsed));
      if (remaining > 0) {
        $count.textContent = _fmtEta(remaining);
      } else {
        $count.textContent = "almost doneâ€¦";
      }
    }, 1000);
  }

  function _fmtEta(secs) {
    if (secs < 60) return secs + "s";
    const m = Math.floor(secs / 60);
    const s = secs % 60;
    return m + "m " + (s < 10 ? "0" : "") + s + "s";
  }

  function _stopEtaCountdown() {
    clearInterval(_etaTimer);
    _etaTimer = null;
  }

  function showLoading(etaSeconds) {
    let etaHtml = '';
    if (etaSeconds && etaSeconds > 0) {
      const fmtEta = etaSeconds < 60
        ? Math.ceil(etaSeconds) + "s"
        : Math.floor(etaSeconds / 60) + "m " + (Math.ceil(etaSeconds % 60) < 10 ? "0" : "") + Math.ceil(etaSeconds % 60) + "s";
      etaHtml = `
        <div class="eta-wrap">
          <div class="eta-bar-outer"><div class="eta-bar-inner" id="etaBar"></div></div>
          <div class="eta-text">
            Estimated time: <span id="etaCount">${fmtEta}</span>
          </div>
        </div>`;
    }
    $content.innerHTML = `
      <div class="loading">
        <div class="spinner"></div>
        Fetching data from Google Playâ€¦ this may take a minute.
        ${etaHtml}
      </div>`;

    if (etaSeconds && etaSeconds > 0) {
      _startEtaCountdown(etaSeconds);
    }
  }

  function showError(msg) {
    $content.innerHTML = `<div class="error">âš ï¸ ${msg}</div>`;
  }

  /**
   * Staggered image loader â€” loads images in small batches with delays
   * to prevent Googleâ€™s image CDN from returning 429.
   */
  let _imgLoadAbort = null;
  function loadImagesStaggered(container) {
    // Cancel any previous staggered load
    if (_imgLoadAbort) _imgLoadAbort.abort = true;
    const ctrl = { abort: false };
    _imgLoadAbort = ctrl;

    const imgs = (container || document).querySelectorAll("img[data-src]");
    if (!imgs.length) return;

    const BATCH = 6;       // images per batch
    const DELAY = 300;     // ms between batches
    let i = 0;

    function loadBatch() {
      if (ctrl.abort) return;
      const end = Math.min(i + BATCH, imgs.length);
      for (; i < end; i++) {
        const img = imgs[i];
        if (img.dataset.src) {
          img.src = img.dataset.src;
          img.removeAttribute("data-src");
        }
      }
      if (i < imgs.length) {
        setTimeout(loadBatch, DELAY);
      }
    }
    // Start first batch after a very short tick
    setTimeout(loadBatch, 50);
  }

  function renderApps(title, apps) {
    let html = `<h2 class="section-title">${title} (${apps.length} apps)</h2><div class="grid">`;
    for (const app of apps) {
      const topClass = app.rank <= 3 ? "top3" : "";
      const stars = app.score ? "â­ " + app.score.toFixed(1) : "";
      html += `
        <div class="card-link" data-appid="${esc(app.appId)}" style="cursor:pointer">
          <div class="card">
            <span class="rank ${topClass}">#${app.rank}</span>
            <img class="icon" data-src="${app.icon}" alt="" loading="lazy" src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='56' height='56'%3E%3Crect fill='%23272a3a' width='56' height='56' rx='12'/%3E%3C/svg%3E" />
            <div class="info">
              <div class="name" title="${esc(app.title)}">${esc(app.title)}</div>
              <div class="dev">${esc(app.developer)}</div>
            </div>
            <div class="meta">
              <div class="installs">${app.installs}</div>
              <div class="rating">${stars}</div>
              <div class="genre">${esc(app.genre)}</div>
            </div>
          </div>
        </div>`;
    }
    html += `</div>`;
    return html;
  }

  function renderKeywords(title, keywords) {
    let html = `<div class="keywords-section">`;
    html += `<h2 class="section-title">${title} (${keywords.length} keywords)</h2>`;
    html += `<div class="keywords-grid">`;
    keywords.forEach((kw, i) => {
      html += `
        <div class="kw-pill">
          <span class="kw-rank">#${i + 1}</span>
          <span class="kw-name">${esc(kw.keyword)}</span>
          <span class="kw-count">${kw.resultCount} apps</span>
        </div>`;
    });
    html += `</div></div>`;
    return html;
  }

  function esc(str) {
    const d = document.createElement("div");
    d.textContent = str || "";
    return d.innerHTML;
  }

  // â”€â”€ Fetch & display â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  let _activeController = null;  // AbortController for the current load

  /**
   * Map a frontend endpoint string to the backend timing key used
   * in the request_timing table.
   */
  function _endpointToTimingKey(ep) {
    if (ep === "/api/top")  return "top";
    if (ep === "anime")     return "anime:apps";       // longest sub-request
    if (ep === "niche-finder") return "niche_scores_all";
    if (ep === "analysis")  return "top";               // loads /api/top
    const catMatch = ep.match(/\/api\/category\/(.+)/);
    if (catMatch) return "category:" + catMatch[1];
    return null;
  }

  /**
   * Fetch estimated duration from the backend for the given timing key.
   * Returns seconds (number) or null if unknown.
   */
  async function _fetchEta(timingKey) {
    if (!timingKey) return null;
    try {
      const res = await fetch("/api/eta?endpoint=" + encodeURIComponent(timingKey));
      if (!res.ok) return null;
      const data = await res.json();
      return data.estimatedSeconds || null;
    } catch (_) { return null; }
  }

  async function loadEndpoint(endpoint) {
    // Welcome page (no scraping needed)
    if (endpoint === "welcome") {
      if (_activeController) _activeController.abort();
      // Refresh cache status before re-rendering
      try {
        const res = await fetch("/api/cache-status");
        const data = await res.json();
        _cacheStatus = data.cache || {};
        _ttlHours    = data.ttlHours || 6;
      } catch (_) {}
      _renderWelcome();
      return;
    }

    // Enforce frontend cooldown
    if (!checkTabCooldown()) return;

    // Cancel any in-flight request (user switched tabs fast)
    if (_activeController) _activeController.abort();
    _activeController = new AbortController();
    const signal = _activeController.signal;

    // Start polling backend throttle status after a short delay
    const pollTimer = setTimeout(() => pollThrottleWhileLoading(signal), 1500);

    if (endpoint === "anime") {
      return loadAnime(signal).finally(() => { clearTimeout(pollTimer); _stopEtaCountdown(); });
    }
    if (endpoint === "niche-finder") {
      return loadNicheFinder(signal).finally(() => { clearTimeout(pollTimer); _stopEtaCountdown(); });
    }
    if (endpoint === "analysis") {
      return loadAnalysis(signal).finally(() => { clearTimeout(pollTimer); _stopEtaCountdown(); });
    }

    // Fetch ETA for this endpoint, show loading with estimate
    const timingKey = _endpointToTimingKey(endpoint);
    const eta = await _fetchEta(timingKey);
    showLoading(eta);
    try {
      const res = await apiFetch(endpoint, { signal });
      if (!res.ok) throw new Error(`HTTP ${res.status}`);
      const data = await res.json();
      if (data.error) throw new Error(data.error);

      // Determine export key
      let exportKey = "top";
      const catMatch = endpoint.match(/\/api\/category\/(.+)/);
      if (catMatch) exportKey = catMatch[1];

      let html = renderToolbar(exportKey);
      html += _renderCacheBanner(exportKey);
      html += renderApps(data.title, data.apps);
      $content.innerHTML = html;
      loadImagesStaggered($content);
      closeThrottleModal();
      // Refresh cache status in background for the welcome page
      _refreshCacheStatus();
    } catch (err) {
      if (err.name === "AbortError") return; // user switched tabs
      showError(err.message);
    } finally {
      clearTimeout(pollTimer);
      _stopEtaCountdown();
    }
  }

  async function loadAnime(signal) {
    const eta = await _fetchEta("anime:apps");
    showLoading(eta);
    try {
      // Fetch keywords and apps sequentially to avoid parallel bursts
      const kwRes = await apiFetch("/api/anime/keywords", { signal });
      if (!kwRes.ok) throw new Error(`Keywords: HTTP ${kwRes.status}`);
      const kwData = await kwRes.json();

      const appRes = await apiFetch("/api/anime/apps", { signal });
      if (!appRes.ok) throw new Error(`Apps: HTTP ${appRes.status}`);
      const appData = await appRes.json();

      let html = "";
      html += renderKeywords(kwData.title, kwData.keywords);
      html += renderApps(appData.title, appData.apps);
      $content.innerHTML = html;
      loadImagesStaggered($content);
    } catch (err) {
      if (err.name === "AbortError") return;
      showError(err.message);
    }
  }

  // â”€â”€ Tab behaviour â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  $tabs.addEventListener("click", (e) => {
    const btn = e.target.closest(".tab-btn");
    if (!btn) return;
    $tabs.querySelectorAll(".tab-btn").forEach(b => b.classList.remove("active"));
    btn.classList.add("active");
    loadEndpoint(btn.dataset.endpoint);
  });

  // â”€â”€ Init: load categories, build welcome page â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const CATEGORY_ICONS = {
    "All":            "ğŸ“±", "Games": "ğŸ®", "Social": "ğŸ’¬", "Entertainment": "ğŸ¬",
    "Productivity":   "âš¡", "Anime": "ğŸŒ", "Health": "â¤ï¸", "Finance": "ğŸ’°",
    "Education":      "ğŸ“š", "AI":    "ğŸ¤–", "Crypto": "â‚¿",  "Shopping": "ğŸ›’",
    "Food":           "ğŸ”", "Travel":"âœˆï¸", "Music":  "ğŸµ", "Photography": "ğŸ“·",
  };

  let _categories = [];
  let _cacheStatus = {};   // label -> {fetchedAt, ageMinutes, fresh}
  let _ttlHours = 6;

  function _timeAgo(minutes) {
    if (minutes < 1)   return "just now";
    if (minutes < 60)  return Math.round(minutes) + "m ago";
    const h = Math.floor(minutes / 60);
    const m = Math.round(minutes % 60);
    return h + "h " + m + "m ago";
  }

  /**
   * Map endpoint to cache label for lookup.
   */
  function _endpointToCacheLabel(ep) {
    if (ep === "/api/top" || ep === "top") return "All (Top 100)";
    if (ep === "anime") return "Anime";
    const catMatch = ep.match(/\/api\/category\/(.+)/);
    if (catMatch) return catMatch[1];
    return null;
  }

  /**
   * Render a small info banner showing cache status for the loaded data.
   */
  function _renderCacheBanner(exportKey) {
    const label = exportKey === "top" ? "All (Top 100)" : exportKey;
    const ci = _cacheStatus[label];
    if (!ci) return '';
    if (ci.fresh) {
      return `<div class="wc-fresh-msg" style="margin-top:0;margin-bottom:14px">
        âœ“ <strong>Loaded from cache</strong> â€” scraped ${_timeAgo(ci.ageMinutes)}.
        No new request was needed. Cache valid for ${_ttlHours}h.
      </div>`;
    }
    return '';
  }

  /** Silently refresh cache status in the background. */
  async function _refreshCacheStatus() {
    try {
      const res = await fetch("/api/cache-status");
      const data = await res.json();
      _cacheStatus = data.cache || {};
      _ttlHours    = data.ttlHours || 6;
    } catch (_) {}
  }

  function _renderWelcome() {
    // Build list of all loadable categories
    const entries = [
      { name: "All (Top 100)", icon: "ğŸ“±", endpoint: "/api/top",             cacheLabel: "All (Top 100)" },
      { name: "Anime",         icon: "ğŸŒ", endpoint: "anime",                cacheLabel: "Anime" },
      { name: "Niche Finder",  icon: "ğŸ”", endpoint: "niche-finder",         cacheLabel: null },
      { name: "Analysis",      icon: "ğŸ“Š", endpoint: "analysis",             cacheLabel: null },
    ];
    for (const cat of _categories) {
      entries.push({
        name: cat,
        icon: CATEGORY_ICONS[cat] || "ğŸ“‚",
        endpoint: `/api/category/${cat}`,
        cacheLabel: cat,
      });
    }

    // Count how many are fresh
    const freshCount = entries.filter(e => e.cacheLabel && _cacheStatus[e.cacheLabel]?.fresh).length;

    let html = `<div class="welcome">`;
    html += `<h2>Welcome â€” What would you like to explore?</h2>`;
    html += `<p class="subtitle">Pick a category below to load its top apps from Google Play.<br>
              Scraping may take several minutes for fresh data. Cached results load instantly.</p>`;

    if (freshCount > 0) {
      html += `<div class="wc-fresh-msg">
        <strong>âœ“ ${freshCount} categor${freshCount === 1 ? 'y has' : 'ies have'} cached data</strong> â€”
        these will load instantly without any delay. Cache is valid for ${_ttlHours} hours.
      </div>`;
    }

    html += `<div class="welcome-grid">`;
    for (const e of entries) {
      const ci = e.cacheLabel ? _cacheStatus[e.cacheLabel] : null;
      let dotClass, cacheText;
      if (!ci) {
        dotClass  = "none";
        cacheText = "not yet scraped";
      } else if (ci.fresh) {
        dotClass  = "fresh";
        cacheText = "cached " + _timeAgo(ci.ageMinutes);
      } else {
        dotClass  = "stale";
        cacheText = "stale â€” " + _timeAgo(ci.ageMinutes);
      }
      html += `
        <div class="welcome-card" onclick="_launchEndpoint('${e.endpoint}')">
          <div class="wc-name">
            <span class="wc-icon">${e.icon}</span>
            ${e.name}
          </div>
          <div class="wc-cache">
            <span class="wc-dot ${dotClass}"></span>
            <span class="wc-cache-text ${dotClass}">${cacheText}</span>
          </div>
        </div>`;
    }
    html += `</div></div>`;
    $content.innerHTML = html;
  }

  /** Launch an endpoint from the welcome page (simulates tab click). */
  function _launchEndpoint(endpoint) {
    // Highlight the matching tab if it exists
    const allBtns = $tabs.querySelectorAll(".tab-btn");
    allBtns.forEach(b => {
      b.classList.toggle("active", b.dataset.endpoint === endpoint);
    });
    loadEndpoint(endpoint);
  }

  (async () => {
    // 1. Load category list
    try {
      const res = await fetch("/api/categories");
      const { categories } = await res.json();
      _categories = categories;
      for (const cat of categories) {
        const btn = document.createElement("button");
        btn.className = "tab-btn";
        btn.dataset.endpoint = `/api/category/${cat}`;
        btn.textContent = cat;
        $tabs.appendChild(btn);
      }
    } catch (_) {}

    // 2. Load cache status (lightweight, no scraping)
    try {
      const res = await fetch("/api/cache-status");
      const data = await res.json();
      _cacheStatus = data.cache || {};
      _ttlHours    = data.ttlHours || 6;
    } catch (_) {}

    // 3. Show welcome page instead of auto-loading
    _renderWelcome();
  })();

  // â”€â”€ Modal logic â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const $modal        = document.getElementById("modal");
  const $modalContent = document.getElementById("modalContent");
  const $modalClose   = document.getElementById("modalClose");

  // Close modal
  $modalClose.addEventListener("click", () => $modal.classList.remove("open"));
  $modal.addEventListener("click", (e) => {
    if (e.target === $modal) $modal.classList.remove("open");
  });
  document.addEventListener("keydown", (e) => {
    if (e.key === "Escape") $modal.classList.remove("open");
  });

  // Open modal on card click
  $content.addEventListener("click", (e) => {
    const link = e.target.closest(".card-link[data-appid]");
    if (!link) return;
    e.preventDefault();
    const appId = link.dataset.appid;
    openAppDetail(appId);
  });

  async function openAppDetail(appId) {
    $modalContent.innerHTML = `
      <div class="loading" style="padding:40px 0">
        <div class="spinner"></div>
        Loading app detailsâ€¦
      </div>`;
    $modal.classList.add("open");

    try {
      const res = await apiFetch(`/api/app/${encodeURIComponent(appId)}`);
      if (!res.ok) throw new Error(`HTTP ${res.status}`);
      const app = await res.json();
      if (app.error) throw new Error(app.error);
      $modalContent.innerHTML = renderDetail(app);
    } catch (err) {
      $modalContent.innerHTML = `<div class="error">âš ï¸ ${esc(err.message)}</div>`;
    }
  }

  function formatNumber(n) {
    if (n >= 1_000_000_000) return (n / 1_000_000_000).toFixed(1) + "B";
    if (n >= 1_000_000)     return (n / 1_000_000).toFixed(1) + "M";
    if (n >= 1_000)         return (n / 1_000).toFixed(1) + "K";
    return String(n);
  }

  function renderDetail(app) {
    const stars = app.score ? "â­ " + app.score.toFixed(1) : "N/A";
    const priceText = app.free ? "Free" : `$${app.price}`;

    // Screenshots
    let screenshotHtml = "";
    if (app.screenshots && app.screenshots.length) {
      screenshotHtml = `<div class="detail-screenshots">`;
      for (const src of app.screenshots) {
        screenshotHtml += `<img src="${src}" alt="screenshot" loading="lazy" />`;
      }
      screenshotHtml += `</div>`;
    }

    return `
      <div class="detail-header">
        <img src="${app.icon}" alt="" />
        <div>
          <div class="detail-title">${esc(app.title)}</div>
          <div class="detail-dev">${esc(app.developer)}</div>
          <span class="detail-genre-badge">${esc(app.genre)} Â· ${esc(app.contentRating || "N/A")}</span>
        </div>
      </div>

      <div class="detail-stats">
        <div class="stat-card">
          <div class="stat-value">${app.installs}</div>
          <div class="stat-label">Downloads</div>
        </div>
        <div class="stat-card">
          <div class="stat-value">${formatNumber(app.realInstalls)}</div>
          <div class="stat-label">Actual Installs</div>
        </div>
        <div class="stat-card">
          <div class="stat-value">${stars}</div>
          <div class="stat-label">Rating</div>
        </div>
        <div class="stat-card">
          <div class="stat-value">${formatNumber(app.ratings || 0)}</div>
          <div class="stat-label">Ratings</div>
        </div>
        <div class="stat-card">
          <div class="stat-value">${formatNumber(app.reviews || 0)}</div>
          <div class="stat-label">Reviews</div>
        </div>
        <div class="stat-card">
          <div class="stat-value">${priceText}</div>
          <div class="stat-label">Price</div>
        </div>
      </div>

      <h3 class="section-title" style="font-size:1rem;margin-bottom:8px">Description</h3>
      <div class="detail-description">${esc(app.description)}</div>

      ${screenshotHtml}

      <div class="detail-footer">
        <a href="${app.url}" target="_blank" rel="noopener">View on Google Play â†—</a>
        <div class="detail-meta-info">
          ${app.released ? "Published: " + esc(app.released) + "<br>" : ""}
          ${app.lastUpdatedOn ? "Updated: " + esc(app.lastUpdatedOn) + "<br>" : ""}
          ${app.version ? "Version: " + esc(app.version) : ""}
        </div>
      </div>
    `;
  }

  // â”€â”€ Toolbar (export + snapshot) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  function renderToolbar(exportKey) {
    return `
      <div class="toolbar">
        <button class="toolbar-btn" onclick="exportCSV('${exportKey}')">ğŸ“¥ Export CSV</button>
        <button class="toolbar-btn" onclick="takeSnapshot()">ğŸ“¸ Save Snapshot</button>
        <button class="toolbar-btn" onclick="showDiff('general_top')">ğŸ“Š Compare Snapshots</button>
      </div>`;
  }

  function exportCSV(key) {
    window.open(`/api/export/${encodeURIComponent(key)}`, "_blank");
  }

  async function takeSnapshot() {
    try {
      const res = await apiFetch("/api/snapshot/save", { method: "POST" });
      const data = await res.json();
      alert(`Snapshot saved! Keys: ${data.keys.join(", ")}`);
    } catch (err) {
      alert("Failed to save snapshot: " + err.message);
    }
  }

  async function showDiff(snapKey) {
    $modalContent.innerHTML = `
      <div class="loading" style="padding:40px 0">
        <div class="spinner"></div>
        Comparing snapshotsâ€¦
      </div>`;
    $modal.classList.add("open");

    try {
      const res = await apiFetch(`/api/snapshot/${encodeURIComponent(snapKey)}/diff`);
      const data = await res.json();
      if (data.error) throw new Error(data.error);
      $modalContent.innerHTML = renderDiff(data);
    } catch (err) {
      $modalContent.innerHTML = `<div class="error">âš ï¸ ${esc(err.message)}</div>`;
    }
  }

  function renderDiff(diff) {
    let html = `<h2 class="section-title" style="margin-bottom:6px">${esc(diff.key)} â€“ Snapshot Diff</h2>`;
    html += `<p style="font-size:.75rem;color:#6b7280;margin-bottom:16px">${diff.previousDate} â†’ ${diff.currentDate}</p>`;

    // New apps
    html += `<div class="diff-section"><h3>ğŸ†• New Apps (${diff.newApps.length})</h3>`;
    if (diff.newApps.length === 0) html += `<p style="font-size:.82rem;color:#6b7280">None</p>`;
    for (const a of diff.newApps) {
      html += `<div class="diff-item">${esc(a.title)} â€” ${formatNumber(a.realInstalls || 0)} installs</div>`;
    }
    html += `</div>`;

    // Dropped apps
    html += `<div class="diff-section"><h3>âŒ Dropped Apps (${diff.droppedApps.length})</h3>`;
    if (diff.droppedApps.length === 0) html += `<p style="font-size:.82rem;color:#6b7280">None</p>`;
    for (const a of diff.droppedApps) {
      html += `<div class="diff-item">${esc(a.title)} â€” ${formatNumber(a.realInstalls || 0)} installs</div>`;
    }
    html += `</div>`;

    // Install changes
    html += `<div class="diff-section"><h3>ğŸ“ˆ Install Changes (top ${diff.installChanges.length})</h3>`;
    for (const c of diff.installChanges) {
      const cls = c.change >= 0 ? "change-positive" : "change-negative";
      const sign = c.change >= 0 ? "+" : "";
      html += `<div class="diff-item">
        ${esc(c.title)}
        <span class="${cls}">${sign}${formatNumber(c.change)}</span>
        (${formatNumber(c.previousInstalls)} â†’ ${formatNumber(c.currentInstalls)})
      </div>`;
    }
    html += `</div>`;
    return html;
  }

  // â”€â”€ Niche Finder â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  async function loadNicheFinder(signal) {
    const eta = await _fetchEta("niche_scores_all");
    showLoading(eta);
    try {
      const res = await apiFetch("/api/niche/scores", { signal });
      if (!res.ok) throw new Error(`HTTP ${res.status}`);
      const data = await res.json();
      if (data.error) throw new Error(data.error);
      $content.innerHTML = renderNicheScores(data.title, data.scores);
    } catch (err) {
      if (err.name === "AbortError") return;
      showError(err.message);
    }
  }

  function renderNicheScores(title, scores) {
    let html = `<h2 class="section-title">${title}</h2>`;
    html += `<div class="niche-grid">`;
    for (const s of scores) {
      const oppClass = s.opportunityScore >= 55 ? "opp-high" : s.opportunityScore >= 35 ? "opp-medium" : "opp-low";
      const barColor = s.opportunityScore >= 55 ? "#34d399" : s.opportunityScore >= 35 ? "#fbbf24" : "#f87171";
      html += `
        <div class="niche-card" onclick="openNicheDetail('${esc(s.niche)}')">
          <div class="niche-name">${esc(s.niche)}</div>
          <span class="opportunity-badge ${oppClass}">${s.opportunityScore}/100</span>
          <div class="score-bar"><div class="score-bar-fill" style="width:${s.opportunityScore}%;background:${barColor}"></div></div>
          <div class="niche-metrics">
            <div class="niche-metric">Keywords: <strong>${s.keywordCount}</strong></div>
            <div class="niche-metric">Avg Results: <strong>${s.avgResultsPerKeyword}</strong></div>
            <div class="niche-metric">Saturation: <strong>${s.saturationPct}%</strong></div>
            <div class="niche-metric">Gap (< 4â˜…): <strong>${s.gapPct}%</strong></div>
            <div class="niche-metric">Fresh Apps: <strong>${s.freshnessPct}%</strong></div>
            <div class="niche-metric">Avg Installs: <strong>${formatNumber(s.avgInstalls)}</strong></div>
          </div>
        </div>`;
    }
    html += `</div>`;
    return html;
  }

  async function openNicheDetail(niche) {
    $modalContent.innerHTML = `
      <div class="loading" style="padding:40px 0">
        <div class="spinner"></div>
        Loading ${esc(niche)} keywordsâ€¦
      </div>`;
    $modal.classList.add("open");

    try {
      const res = await apiFetch(`/api/niche/${encodeURIComponent(niche)}/keywords`);
      if (!res.ok) throw new Error(`HTTP ${res.status}`);
      const data = await res.json();
      $modalContent.innerHTML = renderKeywords(data.title, data.keywords);
    } catch (err) {
      $modalContent.innerHTML = `<div class="error">âš ï¸ ${esc(err.message)}</div>`;
    }
  }

  // â”€â”€ Analysis & Comparison â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  let _cachedAllApps = [];  // cache for dropdown population

  async function loadAnalysis(signal) {
    const eta = await _fetchEta("top");
    showLoading(eta);
    // Load the general top apps for the dropdowns (from DB if cached)
    try {
      const res = await apiFetch("/api/top", { signal });
      if (!res.ok) throw new Error(`HTTP ${res.status}`);
      const data = await res.json();
      _cachedAllApps = data.apps || [];
    } catch (err) {
      if (err.name === "AbortError") return;
      _cachedAllApps = [];
    }

    let optionsHtml = '<option value="">Select an appâ€¦</option>';
    for (const a of _cachedAllApps) {
      optionsHtml += `<option value="${esc(a.appId)}">${esc(a.title)}</option>`;
    }

    $content.innerHTML = `
      <h2 class="section-title">ğŸ“Š App Analysis & Comparison</h2>
      <div class="analysis-panel">
        <p style="font-size:.85rem;color:#9ca3af;margin-bottom:16px">
          Select two apps to compare their descriptions (word overlap) and view install growth from snapshots.
          You can also paste a package ID directly.
        </p>
        <div class="compare-form">
          <label>App 1
            <select id="cmpSel1" onchange="document.getElementById('cmpId1').value=this.value">
              ${optionsHtml}
            </select>
          </label>
          <label>or Package ID
            <input id="cmpId1" placeholder="com.example.app1" />
          </label>
          <label>App 2
            <select id="cmpSel2" onchange="document.getElementById('cmpId2').value=this.value">
              ${optionsHtml}
            </select>
          </label>
          <label>or Package ID
            <input id="cmpId2" placeholder="com.example.app2" />
          </label>
          <button class="compare-btn" onclick="runComparison()">Compare</button>
        </div>
        <div id="compareResults"></div>
      </div>
    `;
  }

  let _chartInstance = null;

  async function runComparison() {
    const id1 = document.getElementById("cmpId1").value.trim();
    const id2 = document.getElementById("cmpId2").value.trim();
    const $results = document.getElementById("compareResults");
    if (!id1 || !id2) {
      $results.innerHTML = '<div class="error">Please select or enter both apps.</div>';
      return;
    }
    $results.innerHTML = `
      <div class="loading" style="padding:30px 0">
        <div class="spinner"></div>Comparing appsâ€¦
      </div>`;

    try {
      // Fetch comparison + install histories in parallel
      const [cmpRes, hist1Res, hist2Res] = await Promise.all([
        apiFetch(`/api/compare?app1=${encodeURIComponent(id1)}&app2=${encodeURIComponent(id2)}`),
        apiFetch(`/api/install-history/${encodeURIComponent(id1)}`),
        apiFetch(`/api/install-history/${encodeURIComponent(id2)}`),
      ]);

      if (!cmpRes.ok) { const e = await cmpRes.json(); throw new Error(e.error || `HTTP ${cmpRes.status}`); }
      const cmp = await cmpRes.json();
      const hist1 = hist1Res.ok ? await hist1Res.json() : { history: [] };
      const hist2 = hist2Res.ok ? await hist2Res.json() : { history: [] };

      $results.innerHTML = renderComparison(cmp, hist1, hist2);

      // Render chart
      renderInstallChart(cmp, hist1, hist2);
    } catch (err) {
      $results.innerHTML = `<div class="error">âš ï¸ ${esc(err.message)}</div>`;
    }
  }

  function renderComparison(cmp, hist1, hist2) {
    const a1 = cmp.app1;
    const a2 = cmp.app2;

    let html = '';

    // Side-by-side app cards
    html += `<div class="compare-result">`;
    html += renderCompareCard(a1, "#7c3aed");
    html += renderCompareCard(a2, "#34d399");
    html += `</div>`;

    // Overlap
    html += `<span class="overlap-badge">Description Overlap: ${cmp.overlapPct}%</span>`;

    // Shared words
    html += `<div class="word-section"><h3>ğŸ”— Shared Keywords (${cmp.sharedWords.length})</h3><div class="word-chips">`;
    for (const w of cmp.sharedWords) {
      html += `<span class="word-chip shared">${esc(w.word)} (${w.countApp1}/${w.countApp2})</span>`;
    }
    html += `</div></div>`;

    // Only App 1
    html += `<div class="word-section"><h3>ğŸŸ£ Only in ${esc(a1.title)} (${cmp.onlyApp1.length})</h3><div class="word-chips">`;
    for (const w of cmp.onlyApp1) {
      html += `<span class="word-chip only1">${esc(w.word)} (${w.count})</span>`;
    }
    html += `</div></div>`;

    // Only App 2
    html += `<div class="word-section"><h3>ğŸŸ¢ Only in ${esc(a2.title)} (${cmp.onlyApp2.length})</h3><div class="word-chips">`;
    for (const w of cmp.onlyApp2) {
      html += `<span class="word-chip only2">${esc(w.word)} (${w.count})</span>`;
    }
    html += `</div></div>`;

    // Chart placeholder
    html += `
      <div class="chart-container">
        <h3 class="section-title" style="font-size:1rem;margin-bottom:10px">ğŸ“ˆ Install Growth (from snapshots)</h3>
        <canvas id="installChart"></canvas>
        ${(hist1.history.length === 0 && hist2.history.length === 0)
          ? '<p style="font-size:.82rem;color:#6b7280;margin-top:8px">No snapshot history yet. Save snapshots over time to see growth.</p>'
          : ''}
      </div>`;

    return html;
  }

  function renderCompareCard(app, borderColor) {
    const stars = app.score ? "â­ " + app.score.toFixed(1) : "N/A";
    return `
      <div class="compare-app-card" style="border-top:3px solid ${borderColor}">
        <div class="app-hdr">
          <img src="${app.icon}" alt="" />
          <div>
            <div class="app-title">${esc(app.title)}</div>
            <div class="app-dev">${esc(app.developer)}</div>
          </div>
        </div>
        <div class="niche-metrics">
          <div class="niche-metric">Installs: <strong>${app.installs}</strong></div>
          <div class="niche-metric">Rating: <strong>${stars}</strong></div>
          <div class="niche-metric">Ratings: <strong>${formatNumber(app.ratings || 0)}</strong></div>
          <div class="niche-metric">Genre: <strong>${esc(app.genre)}</strong></div>
          <div class="niche-metric">Released: <strong>${esc(app.released || "N/A")}</strong></div>
          <div class="niche-metric">Words: <strong>${app.totalWords} (${app.uniqueWords} unique)</strong></div>
        </div>
      </div>`;
  }

  function renderInstallChart(cmp, hist1, hist2) {
    const canvas = document.getElementById("installChart");
    if (!canvas) return;

    // Destroy previous chart
    if (_chartInstance) { _chartInstance.destroy(); _chartInstance = null; }

    // Merge dates
    const allDates = new Set();
    for (const h of hist1.history) allDates.add(h.date.slice(0, 10));
    for (const h of hist2.history) allDates.add(h.date.slice(0, 10));

    if (allDates.size === 0) {
      // No snapshot data â€” show current installs as a single bar
      _chartInstance = new Chart(canvas.getContext("2d"), {
        type: "bar",
        data: {
          labels: [cmp.app1.title, cmp.app2.title],
          datasets: [{
            label: "Current Installs",
            data: [cmp.app1.realInstalls, cmp.app2.realInstalls],
            backgroundColor: ["#7c3aed", "#34d399"],
            borderRadius: 6,
          }],
        },
        options: {
          responsive: true,
          plugins: { legend: { display: false } },
          scales: {
            y: { ticks: { color: "#9ca3af" }, grid: { color: "#272a3a" } },
            x: { ticks: { color: "#9ca3af" }, grid: { display: false } },
          },
        },
      });
      return;
    }

    const labels = [...allDates].sort();
    const map1 = {};
    const map2 = {};
    for (const h of hist1.history) map1[h.date.slice(0, 10)] = h.realInstalls;
    for (const h of hist2.history) map2[h.date.slice(0, 10)] = h.realInstalls;

    _chartInstance = new Chart(canvas.getContext("2d"), {
      type: "line",
      data: {
        labels,
        datasets: [
          {
            label: cmp.app1.title,
            data: labels.map(d => map1[d] ?? null),
            borderColor: "#7c3aed",
            backgroundColor: "rgba(124,58,237,.15)",
            fill: true, tension: .3, spanGaps: true,
          },
          {
            label: cmp.app2.title,
            data: labels.map(d => map2[d] ?? null),
            borderColor: "#34d399",
            backgroundColor: "rgba(52,211,153,.15)",
            fill: true, tension: .3, spanGaps: true,
          },
        ],
      },
      options: {
        responsive: true,
        interaction: { mode: "index", intersect: false },
        plugins: {
          legend: { labels: { color: "#e0e0e0" } },
        },
        scales: {
          y: { ticks: { color: "#9ca3af" }, grid: { color: "#272a3a" } },
          x: { ticks: { color: "#9ca3af" }, grid: { color: "#272a3a" } },
        },
      },
    });
  }
</script>

</body>
</html>
